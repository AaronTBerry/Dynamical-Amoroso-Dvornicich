# coding: utf-8


# This file was *autogenerated* from the file Downloads/DynamicalHeight.sage
from sage.all_cmdline import *   # import sage library

_sage_const_200 = Integer(200); _sage_const_0 = Integer(0); _sage_const_1p3862943611198906188344642429163531361510002687205105082414 = RealNumber('1.3862943611198906188344642429163531361510002687205105082414'); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_53 = Integer(53); _sage_const_10 = Integer(10); _sage_const_54 = Integer(54)#!/usr/bin/env python

# In[1]:


#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>#
#                      DYNAMICAL HEIGHT                      #
#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>#

load('QpAlgebra.py')

#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>#

# These bounds are manually calculated (see "Bounds.py")
# If calculating height for a different rational map
# compute new bounds

R = RealField(_sage_const_200 )
bounds = { _sage_const_0  : _sage_const_1p3862943611198906188344642429163531361510002687205105082414  }
from sage.rings.real_mpfr import (RealField, is_RealField)
height_diff_bound = sum(bounds[p] for p in bounds.keys())

#<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>#

def Phi(tuple):
    X = tuple[_sage_const_0 ]
    Y = tuple[_sage_const_1 ]
    return (X**_sage_const_2  - Y**_sage_const_2 , Y**_sage_const_2 )


def height(f, err=None, prec=None, lower_bound=None, debug=False, totals=False):
    """
    Computes the canonical height to the desired precision, and
    if the value is ever provably above the lower bound, if specified,
    then the computation stops striving for the desired accuracy, and
    just returns that estimate that is provably above the lower bound.
    
    This is because we are searching for points of low (but positive)
    and height, and are not interested in accuractely estimating points
    which are above our threshold anyway.
    """
    if not f.is_irreducible():
        raise(ValueError, "Polynomial must be irreducible over ZZ.")
    if prec is None: prec = _sage_const_53 
    R = RealField(prec=prec)
    if err is None:
        err = R(_sage_const_2 )**(-prec)
    primes_to_do = f.leading_coefficient().prime_factors()
    # 0 should be in bound.keys() for the archimedean place of QQ (and then by extension arch places of K)
    for p in list(bounds.keys()):
        if p not in primes_to_do:
            primes_to_do.append(p)
    if debug or totals: print("Primes to do are:", primes_to_do)
    # quick and dirty signature of field generated by f
    r = f.number_of_real_roots()
    s = (f.degree() - r) // _sage_const_2  # better be an integer!
    
    ## Before I sent a desired accuracy to each place, now, we're just going to compute where we
    ## are at each place individually... 
    #num_places = len(primes_to_do) + r + s - 1 # -1 because we already counted "0" once for arch places
    # err = err / num_places
    ###################################
    ### MAIN LOOP IS ABOUT TO START ###
    ###################################
    d = _sage_const_2 
    i = _sage_const_0 
    # Initialize variables that will be locally indexed
    N = dict()
    X = dict()
    Qpr = dict()
    QpX = dict()
    QpA = dict()
    factors = dict()
    dv = dict()
    ht = dict() # This will track the tallies of the re-scaling factors that pop out
    a1 = dict()
    # cur_local_err_bound = dict() # Keep track of achieved accuracy at each place
    done = False # Variable to mark when desired precision is achieved
    while not done:
        # RESET h each loop, because we are having some terms that are not kept
        h = R.zero()
        if debug or totals: print("\nwhile loop starting (again); resetting h...")
        if debug or totals: print("i =", i, "****************************************************************")
        for p in primes_to_do:
            if debug or totals: print("\nCurrently working on prime p =", p, '\n-----------------------------------------------\n')
            # We need to check if we are a bad place; if so we'll be looping,
            # if not, we only run ONCE and then don't contribute to the error
            if p > _sage_const_0 : # finite prime
                #if p not in bounds.keys(): # good finite place has no error
                #    cur_local_err_bound[p] = R.zero()
                # TODO: Add a check for i vs. the local accuracy
                if i == _sage_const_0 :
                    padic_prec = Integer(RR(prec*RR(_sage_const_2 ).log(p)).ceil())
                    # if debug: print("Computed padic_prec =", padic_prec)
                    Qpr[p] = Qp(p, prec=padic_prec+_sage_const_10 ) # A little breathing room here? Is this useful?
                    QpX[p] = PolynomialRing(Qpr[p], 'x')
                    factors[p] = QpX[p](f).factor()
                for P, e in factors[p]:
                    if i == _sage_const_0 : # One time initializations
                        ht[P] = R.zero() # Initialize the ht local 
                        a1[P] = var('a1')
                        if P.degree() > _sage_const_1 :
                            QpA[P] = QpAlgebra(P, 'a' + str(i), abs_prec=prec)
                            a1[P] = QpA[P].gen()
                        else: # degree 1 case, the factor is linear, and has one root. That's our alpha_1.
                            a1[P] = P.roots()[_sage_const_0 ][_sage_const_0 ]
                        dv[P] = P.degree()*e
                        X[P] = (a1[P], _sage_const_1 )
                    # Don't iterate on X yet, since we'll have a 0 loop first... 
                    if i > _sage_const_0  and p in bounds.keys(): # Only do the rescaling process if i > 0
                        # if debug: print("Phi^" + str(i) + "(X) =", X[P], "\nNow rescaling if necessary...")
                        x1 = X[P][_sage_const_0 ]; y1 = X[P][_sage_const_1 ] # These are truly temporary and don't need to be indexed...
                        # :: TODO:
                        # Add a handler for the case where this doesn't get coerced into QpA:
                        # if x1 in QQ or x1 in ZZ:
                            # ...
                        mx = _sage_const_0 ; my = _sage_const_0 
                        if P.degree() > _sage_const_1 : # case of Qp Algebra
                            mx = min(z.valuation() for z in QpA[P](x1))
                            my = min(z.valuation() for z in QpA[P](y1))
                        else: # linear case
                            mx = Qpr[p](x1).valuation()
                            my = Qpr[p](y1).valuation()
                        m = min(mx, my)
                        X[P] = (p**(-m)*x1, p**(-m)*y1)
                        if m != _sage_const_0 : # No shift it not rescaling... 
                            ht[P] += dv[P]*(-m)*R(p).log()/(d**(i)) # N.B. was i + 1 in initial code
                        if (debug or totals) and m != _sage_const_0 :
                            print("Rescaling by", p**(-m)) #, "new X =", X[P])
                            print("Adding to ht, now =", ht[P])
                        if debug and m == _sage_const_0 : print("No rescaling necessary (this time)")
                    if p in bounds.keys(): 
                        j = i # bad place, scale with each iteration we make
                    else:
                        j = _sage_const_0  # good place, never increment
                    if debug:
                        print("tally of scaling factors at P =", P, "\nis ht =\n", ht[P])
                        print(" 1/d^i log || Î¦^i(X) || =", R(max([z.abs() for z in X[P]])).log()/(d**j))
                    if totals: 
                        print("At place over", p, "of degree", P.degree(), "we have")
                        print("h =", ht[P] + dv[P]*R(max([z.abs() for z in X[P]])).log()/(d**j))
                    h += ht[P] + dv[P]*R(max([z.abs() for z in X[P]])).log()/(d**j)
                    # NOW iterate on X for the next loop... 
                    # Actually we only do the iteration at a bad place, remember...
                    # otherwise we're stressing the computations, when the valuation 
                    # should NOT be changing!
                    if p in bounds.keys(): # Bad prime -- make a separate list?
                        X[P] = Phi(X[P])
            elif p == _sage_const_0 : # infinite prime
                if i == _sage_const_0 :
                    # IDEA: Skip creating the number field and go by roots of f directly?
                    K = NumberField(f, names=('a',)); (a,) = K._first_ngens(1)
                    if prec == _sage_const_53 :
                        places_prec = _sage_const_54 
                    else:
                        places_prec = prec
                    emb = K.places(prec=places_prec)
                    for v in emb:
                        # Remember h gets reset each i loop, so this will track what we have so far
                        # So initialize it the first time
                        ht[v] = R.zero()
                        X[v] = (v(a), _sage_const_1 )
                        if isinstance(v.codomain(), sage.rings.abc.RealField) or v.codomain() is RDF:
                            dv[v] = R.one()
                            # C[v] = R
                        else:
                            dv[v] = R(_sage_const_2 )
                            # C[v] = ComplexField(prec=prec)
                # Archimedean local heights
                # :: WARNING: If places is fed the default Sage precision of 53 bits,
                # it uses Real or Complex Double Field in place of RealField(prec) or ComplexField(prec)
                # the function is_RealField does not identify RDF as real, so we test for that ourselves.
                for v in emb:
                    # if debug: print(X)
                    Qv = [ t.abs() for t in X[v] ]
                    # if debug: print(Qv)
                    m = -_sage_const_1 
                    #compute the maximum absolute value of entries of a, and where it occurs
                    for n in range(_sage_const_2 ):
                        if Qv[n] > m:
                            j = n
                            m = Qv[n]
                    #if debug: print("j =", j, "m =", m)
                    # add to sum for the Green's function
                    #if debug: print("Adding to the local height a factor of", ((1/R(d))**i) * (R(m).log()))
                    ht[v] += ((_sage_const_1 /R(d))**i) * (R(m).log()) # at i = 0 this is just the initial log ||P|| value
                    #get the next iterate ready
                    X[v] = (X[v][_sage_const_0 ]/X[v][j], X[v][_sage_const_1 ]/X[v][j])
                    X[v] = Phi(X[v])
                    if debug: print("For place v =", v)
                    if debug or totals: print("We get local height =", ht[v], "* dv of", dv[v], "=", dv[v] * ht[v])
                    h += dv[v] * ht[v]
        # back in the main while loop, finally!
        h = h / f.degree()
        if debug:
            print("End of loop i =", i, "\nCurrent estimate after normalization by the degree is that\nh =", h)
            print("\n")
        cur_err = R(height_diff_bound) / R(d)**i
        if debug: print("Current accuracy is", cur_err)
        if lower_bound is not None:
            if h - cur_err > lower_bound:
                if debug: print("Computed h - cur_err =", h - cur_err, "> lower_bound =", lower_bound, "\nso we are done.")
                done = True
        if cur_err < err:
            if debug: print("cur_err =", cur_err, "< err =", err, "\nso we are done.")
            done = True
        # Finally, if we are not done? increment i
        i += _sage_const_1 
    return h

